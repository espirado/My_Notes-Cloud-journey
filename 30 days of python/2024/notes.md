Week 1: Pythonic OOP, Test-Driven Python, and Scaling Python with Generators
Day 1: Pythonic OOP - The Single-Responsibility Principle
Theory: Understand the SRP and its importance in object-oriented design.
Practice: Write a class that handles a single responsibility (e.g., a BookManager that manages books).
Challenge: Refactor a class that violates SRP.
Day 2: Inheritance & Refactoring for Inheritance
Theory: Explore inheritance, superclasses, and subclasses.
Practice: Refactor a class hierarchy (e.g., Person, Student, Teacher).
Challenge: Use inheritance to reduce code duplication and introduce new functionality.
Day 3: Pythonic Interfaces, Methods, and Inheritance
Theory: Learn about interfaces and abstract base classes in Python.
Practice: Create classes that implement interfaces (use the abc module).
Challenge: Create an interface for a notification system (Email, SMS), and refactor methods using inheritance.
Day 4: Access Control, Properties, and Refactoring
Theory: Explore private/protected methods and properties in Python.
Practice: Implement property decorators for data validation (e.g., valid book prices or page counts).
Challenge: Refactor a class with getter/setter methods into using properties.
Day 5: Factories, Class Methods, Static Methods, and Pythonic Design Patterns
Theory: Understand different types of methods and patterns such as Factory and Singleton.
Practice: Implement a Factory pattern (e.g., for creating objects based on user input).
Challenge: Refactor a system that creates objects (e.g., vehicles) using class methods and static methods.
Day 6: Test-Driven Python - Foundations of Automated Testing
Theory: Explore unit tests, test discovery, and unittest in Python.
Practice: Write unit tests for a class you built (e.g., BookManager).
Challenge: Implement a test-driven workflow by writing tests first for a new feature.
Day 7: Types of Tests and Test-Driven Development
Theory: Learn about unit tests, integration tests, and TDD.
Practice: Implement TDD for a small feature (e.g., add search functionality to BookManager).
Challenge: Refactor a codebase and ensure tests pass throughout the process.
Week 2: Higher-Order Python, Python Code Walkthroughs, and Practical Python Engineering
Day 8: Scaling Python with Generators
Theory: Learn about generators and the iteration protocol in Python.
Practice: Write a generator that processes a large dataset (e.g., large text files).
Challenge: Implement a generator comprehension and refactor an existing loop to use generators.
Day 9: Higher-Order Python - Functions as Objects, Decorators
Theory: Explore how functions are objects and decorators in Python.
Practice: Write a basic decorator and apply it to functions (e.g., for logging).
Challenge: Implement a stateful decorator to track how many times a function has been called.
Day 10: Class-Based Decorators and Higher-Order Decorators
Theory: Learn about class-based decorators and higher-order decorators.
Practice: Refactor a decorator to be class-based (e.g., timing a function’s execution).
Challenge: Chain multiple decorators together in an example.
Day 11: Python Code Walkthroughs
Theory: Go through codebases for real-world Python projects.
Practice: Walk through the DateInterval class, lookupemails.py, and refactor the EmailAnonymizer class.
Challenge: Analyze and refactor special methods in a given codebase to make them more Pythonic.
Day 12: Practical Python Engineering - Errors and Exceptions, Logging
Theory: Explore error handling, logging, and exceptions in Python.
Practice: Write error-handling logic for your project, ensuring proper logging for failures.
Challenge: Add robust error handling to an existing Python project (e.g., a BookManager project).
Day 13: Python Dependency Management and Command-Line Python Programs
Theory: Learn about Python dependency management tools (pip, virtualenv, poetry) and command-line applications.
Practice: Build a small command-line Python program (e.g., a book inventory system).
Challenge: Refactor an existing project to be installable via pip, with proper dependency management.
Day 14: Project Implementation - Web Service
Theory: Use the skills you’ve acquired to start a full project from scratch.
Practice: Begin implementing a web service using Flask/Django following TDD principles.
Challenge: Apply version control and follow best practices to ensure code quality.